use warnings;
use strict;

=head1 NAME

BTDT::Action::BulkUpdateTasks

=cut

# XXX TODO: A lot of this code duplicates functionality in
# BTDT::Action::UpdateTask. Possibly this should be refactored into
# Jifty code and autogenerated

package BTDT::Action::BulkUpdateTasks;

use base qw/BTDT::Action Jifty::Action/;
use BTDT::Action::ArgumentCacheMixin;
use Number::RecordLocator;

=head2 arguments

C<BulkUpdateTasks> takes the following arguments:

=over 4

=item ids

A list of ids to perform the requested updates to.

=item add_tags

A list of tags to add

=item remove_tags

A list of tags to remove

=item group

The group ID of a group to move the tasks to; -1 for ``Personal''

=item due

A new due date for the tasks

=item begins

A new C<begins> (``Hide until'') date for the tasks

=item priority

A priority value to set the tasks to

=item accepted

Whether to accept or decline these tasks if unaccepted, or neither

=item comment

A comment to add to all these tasks

=item delete

If true, delete all selected tasks.

=back

=cut

sub arguments {
    my $self = shift;

    return $self->{__cached_arguments} if ($self->{__cached_arguments});

    my $args = {
        ids         => {
            render_as     => 'Hidden',
            documentation => 'The tasks to update',
        },
        tokens => {
            render_as     => 'Hidden',
            documentation => 'The tokens of the tasks to update',
        },
        add_tags    => { label       => 'Add Tags' },
        remove_tags => { label       => 'Remove Tags' },
        add_dependency_on => { label => 'But first' },
        add_depended_on_by => { label => 'And then' },
        remove_dependency_on => { label => 'Remove "But first"' },
        remove_depended_on_by => { label => 'Remove "And then"' },
        group   => {
            label        => 'Move to group',
            render_as    => 'Select',
            valid_values => [
              {
                  display => "Don't change",
                  value   => 0,
              },
              {   display => 'Personal',
                  value   => -1,
              },
              {   display_from => 'name',
                  value_from   => 'id',
                  collection   => Jifty->web->current_user->user_object->groups,
              },
             ],
            default_value => 0
           },
        due       => { label          => 'Due on',
                       render_as      => 'Date' },
        starts    => { label          => 'Hide until',
                       render_as      => 'Date' },
        complete  => { label          => 'Done',
                       render_as      => 'Checkbox' },
        owner_id  => { label          => 'Owner',
                       ajax_validates => 1,
                       autocompleter  => \&BTDT::Model::Task::autocomplete_owner_id },
        priority  => { label          => 'Priority',
                       valid_values   => [
                         { display => "Don't change", value => 0 },
                         @{ BTDT::Model::Task->column('priority')->valid_values },
                        ],
                       render_as      => 'Select',
                       default_value  => 0 },
        accepted  => { label          => 'Accepted',
                       valid_values   => [
                         { display => 'accepted', value => '1' },
                         { display => 'declined', value => '0' },
                         { display => "Don't change", value => '' },
                        ],
                       default_value  => '',
                       render_as      => 'Select',
                   },
        comment   => { label          => 'Add Comment',
                       render_as      => 'textarea'},
        delete    => { label          => 'Delete',
                       render_as      => 'Checkbox' },
        will_complete => { label      => "Don't hide forever",
                           render_as  => 'Checkbox' },
        will_not_complete => { label      => 'Hide forever',
                               render_as  => 'Checkbox' },
        time_left => {
            label               => 'Time left',
            render_as           => 'Text',
            ajax_validates      => 1,
            ajax_canonicalizes  => 1,
        },
        project => {
            label        => 'Move to project',
            render_as    => 'Select',
            valid_values => [
              {
                  display => "Don't change",
                  value   => 0,
              },
              {   display => '(Remove)',
                  value   => -1,
              },
             ],
            default_value => 0
        },
        milestone => {
            label        => 'Move to milestone',
            render_as    => 'Select',
            valid_values => [
              {
                  display => "Don't change",
                  value   => 0,
              },
              {   display => '(Remove)',
                  value   => -1,
              },
             ],
            default_value => 0
        },
    };

    return $self->{__cached_arguments} = $args;
}

=head2 set_valid_projects

Set the valid projects for this bulk update, based on the group.

=head2 set_valid_milestones

Set the valid milestones for this bulk update, based on the group.

=cut

# we need to be able to set the valid projects and milestones for a tasklist.
# because projects and milestones are specific to a single group, and we don't
# know what group the tasklist is in, we need to empower the user with the
# ability to let us know.
# since __cached_arguments is cached only for a particular instance of an
# action, it's safe to modify it
do {
    my $set_valid_things = sub {
        my $self   = shift;
        my $name   = shift;
        my $things = shift;

        # force the cache to be populated
        $self->arguments;

        my $valid_values = $self->{__cached_arguments}->{$name}->{valid_values};
        @$valid_values = (
            {
                display => "Don't change",
                value   => 0,
            },
            {   display => "Remove $name",
                value   => -1,
            },
        );

        while (<$things>) {
            push @$valid_values, {
                display => $_->summary,
                value   => $_->id,
            };
        }

        return $valid_values;
    };

    sub set_valid_projects {
        my $self = shift;
        my $projects = shift;

        $self->$set_valid_things(project => $projects);
    }

    sub set_valid_milestones {
        my $self = shift;
        my $milestones = shift;

        $self->$set_valid_things(milestone => $milestones);
    }
};

sub _validate_valid_values {
    my $self = shift;
    my $field = shift;
    my $value = shift;

    # we need to examine the project or milestone to make sure that it makes
    # sense for the group (that we may be updating tasks into)
    if ($field eq 'milestone' || $field eq 'project') {
        my $group_id;

        if ($self->argument_value('group')) {
            # if they are changing the group, then check that
            $group_id = $self->argument_value('group');
        }
        elsif (my $tokens = $self->argument_value('tokens')) {
            # otherwise, check the tokens for a single group
            my $tasks = BTDT::Model::TaskCollection->new;
            $tasks->from_tokens(
                BTDT::Model::TaskCollection->split_tokens($tokens)
            );
            my %defaults = $tasks->all_defaults;

            # ignore the personal group
            my @groups = grep { $_ != 0 } @{ $defaults{group_id} || [] };

            # we want only a single group
            $group_id = $groups[0] if @groups == 1;
        }

        # no known group, or the personal pseudogroup
        return 0 if !$group_id || $group_id == -1;

        # is the group for this project/milestone sane?
        my $class = "BTDT::" . ucfirst($field);
        my $thing = $class->new;
        $thing->load($value);

        return $self->validation_ok($field) if $thing->group->id == $group_id;

        return $self->validation_error(
            $field => _("That doesn't look like a correct value")
        );
    }

    return $self->SUPER::_validate_valid_values($field, $value, @_);
}

=head2 validate_owner_id

See L<BTDT::Action::UpdateTask::validate_owner_id>. This allows setting the
owner to C<nobody> even if there's no group. When we actually run the action,
we will just skip over any personal task's update of owner to C<nobody>.

=cut

sub validate_owner_id {
    my $self = shift;
    my $value = shift;

    return BTDT->validate_user_email(
        action    => $self,
        column    => "owner_id",
        value     => $value,
        empty     => 1,
        implicit  => 1,
        group     => $self->argument_value('group'),
        nobody_ok => 1,
    );
}

sub _valid_task_id {
    my $self = shift;
    my $column = shift;
    my $value = shift;

    return 1 if !$value || $value =~ /^\s*$/;
    return 1 if $value =~ /^[0-9]+$/;
    return 0;
}

sub _validate_task_list {
    my $self = shift;
    my $column = shift;
    my $value = shift;

    return undef unless defined $value;
    for my $v (split ' ', $value) {
        if (!$self->_valid_task_id($column, $v)) {
            return $self->validation_error(
                $column => "Are you sure that's a task ID?",
            );
        }
    }

    return $self->validation_ok($column);
}

=head2 validate_add_dependency_on, validate_add_depended_on_by, validate_remove_dependency_on, validate_remove_depended_on_by

Ensure that the new/removed dependencies are real task IDs.

=cut

sub validate_add_dependency_on { (shift)->_validate_task_list('add_dependency_on', @_) }
sub validate_add_depended_on_by { (shift)->_validate_task_list('add_depended_on_by', @_) }
sub validate_remove_dependency_on { (shift)->_validate_task_list('remove_dependency_on', @_) }
sub validate_remove_depended_on_by { (shift)->_validate_task_list('remove_depended_on_by', @_) }

sub _canonicalize_task_id {
    my $self = shift;
    my $value = shift;
    return undef unless defined $value && $value =~ /#([a-zA-Z0-9]+)/;
    return Number::RecordLocator->new->decode($1);
}

sub _canonicalize_task_list {
    my $self = shift;
    my $value = shift;

    return undef unless defined $value;
    return join ' ',
           map { $self->_canonicalize_task_id($_) }
           grep { /\S/ }
           split /[ ,;]+/, $value;
}

=head2 canonicalize_add_dependency_on, canonicalize_add_depended_on_by, canonicalize_remove_dependency_on, canonicalize_remove_depended_on_by

Transform record locators to IDs

=cut

sub canonicalize_add_dependency_on { return (shift)->_canonicalize_task_list(@_) }
sub canonicalize_add_depended_on_by { return (shift)->_canonicalize_task_list(@_) }
sub canonicalize_remove_dependency_on { return (shift)->_canonicalize_task_list(@_) }
sub canonicalize_remove_depended_on_by { return (shift)->_canonicalize_task_list(@_) }

=head2 validate_time_left

The time left must look like a time value
(see L<BTDT::Model::Task/_validate_time>)

=cut

sub validate_time_left {
    my $self = shift;
    my ( $ok, $error ) = BTDT::Model::Task->validate_time_left(@_);

    return $ok
        ? $self->validation_ok('time_left')
        : $self->validation_error('time_left' => $error);
}

=head2 canonicalize_time_left

Uses L<BTDT::Model::Task/_canonicalize_time>

=cut

sub canonicalize_time_left {
    my $self = shift;
    return BTDT::Model::Task->canonicalize_time_left(@_);
}

=head2 take_action

Apply the changes indicated to the tasks given by C<ids>

=cut

sub take_action {
    my $self = shift;
    my @tasks = ();
    my $task;

    my $ids = $self->argument_value('ids');
    my @ids = ref $ids ? @$ids : split ' ', $ids;

    for my $id (@ids) {
        $task = BTDT::Model::Task->new();
        $task->load($id);
        push @tasks, $task;
    }

    for $task (@tasks) {
        BTDT::Action::ArgumentCacheMixin->invalidate_cache($task);
        if ($self->argument_value('delete')) {
            $task->delete;
            next;
        }

        if ($self->argument_value('add_tags')) {
            $task->set_tags($task->tags . " " . $self->argument_value('add_tags'));
        }
        if ($self->argument_value('remove_tags')) {
            my %tags = map {$_ => 1} $task->tag_array();
            delete $tags{$_} for ($BTDT::Model::Task::TAGS_PARSER->parse_tags($self->argument_value('remove_tags')));
            $task->set_tags($BTDT::Model::Task::TAGS_PARSER->join_tags(keys %tags));
        }

        for my $type (qw/add_dependency_on add_depended_on_by remove_dependency_on remove_depended_on_by/) {
            if (my $deps = $self->argument_value($type)) {
                for my $dep (split ' ', $deps) {
                    $task->$type( $dep ) unless $dep == $task->id;
                }
            }
        }

        if ($self->argument_value('group')) {
            my $group = $self->argument_value('group');
            $group = undef if $group == -1;
            $task->set_group_id($group);
        }
        if ($self->argument_value('comment')) {
            $task->comment($self->argument_value('comment'));

        }
        for my $field (qw(due starts complete priority accepted time_left project milestone)) {
            if (my $value = $self->argument_value($field)) {
                my $method = "set_" . $field;
                $task->$method($value);
            }
        }
        if ($self->argument_value('will_complete')) {
            $task->set_will_complete(1);
        }
        if ($self->argument_value('will_not_complete')) {
            $task->set_will_complete(0);
        }

        # Make sure the owner_id apply happens *after* the accepted,
        # so that you can't bulk-assign a bunch of tasks to someone,
        # and then accept them for them at once.

        if ( $self->argument_value('owner_id') ) {
            my $email = $self->argument_values->{'owner_id'};
            if ( $email =~ /\@/ ) {
                my $owner =
                  BTDT::Model::User->new(
                    current_user => BTDT::CurrentUser->superuser );
                $owner->load_or_create( email => $email );
                $task->set_owner_id( $owner->id );
            }
            elsif ( lc $email eq 'nobody' ) {
                # don't update personal tasks to be owned by nobody!
                # this must be done AFTER group is (possibly) updated
                if ($task->group_id) {
                    $task->set_owner_id( BTDT::CurrentUser->nobody->id );
                }
            }
            else {
                $task->set_owner_id($email);
            }
        }

    }

    for my $var (Jifty->web->request->state_variables) {
        Jifty->web->request->remove_state_variable($var->key);
    }

    $self->result->message(($self->argument_value('delete') ? "Deleted " : "Updated ")
                           . (scalar @tasks) . " tasks.");
}

1;
